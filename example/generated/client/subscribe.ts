/** generated by
 * - commection in unloss
 * - https://jsr.io/@narumincho/js-ts-code-generator@0.8.2
 * Do not edit!
 *
 * @module
 */

import * as a from "../../../runtime/client/store.ts";
import * as b from "../common/id.ts";
import * as c from "../common/type.ts";
import * as d from "../../../runtime/client/callbacksAndDataState.ts";
import * as e from "../../../runtime/client/callbacksAndDataStateMap.ts";
import * as f from "../common/filterType.ts";
import * as g from "./request.ts";
import * as h from "../common/filterSearchParamsCodec.ts";
const scheduledSymbol: unique symbol = Symbol();

/**
 * Commection の状態
 */
export type CommectionState = {
  readonly collectionStore: a.Store<b.CollectionId, c.Collection>;
  readonly brandStore: a.Store<b.BrandId, c.Brand>;
  readonly accountStore: a.Store<b.AccountId, c.Account>;
  myAccount: d.CallbacksAndDataState<c.Account> | undefined;
  readonly accountPrivateAndCallbacksMap: e.CallbacksAndDataStateMap<
    b.AccountId,
    c.AccountPrivate
  >;
  readonly designerAndCallbacksMap: e.CallbacksAndDataStateMap<
    b.DesignerId,
    c.Designer
  >;
  readonly itemStore: a.Store<b.ItemId, c.Item>;
  readonly itemImageAndCallbacksMap: e.CallbacksAndDataStateMap<
    b.ItemId,
    c.ItemImage
  >;
  readonly itemEventStore: a.Store<b.ItemEventId, c.ItemEvent>;
  readonly itemEventTypeStore: a.Store<b.ItemEventTypeId, c.ItemEventType>;
  readonly bearerToken: string | undefined;
  [scheduledSymbol]: boolean;
};

export const createCommectionState = (
  bearerToken: string | undefined,
): CommectionState => ({
  collectionStore: a.createStore(),
  brandStore: a.createStore(),
  accountStore: a.createStore(),
  myAccount: undefined,
  accountPrivateAndCallbacksMap: new Map([]),
  designerAndCallbacksMap: new Map([]),
  itemStore: a.createStore(),
  itemImageAndCallbacksMap: new Map([]),
  itemEventStore: a.createStore(),
  itemEventTypeStore: a.createStore(),
  bearerToken,
  [scheduledSymbol]: false,
});

export type RequestFragment = {
  readonly resourceName: "Collection";
  readonly target: {
    readonly type: "filter";
    readonly filter: f.CollectionFilter;
  } | { readonly type: "byIdSet"; readonly idSet: ReadonlySet<b.CollectionId> };
} | {
  readonly resourceName: "Brand";
  readonly target:
    | { readonly type: "filter"; readonly filter: f.BrandFilter }
    | { readonly type: "byIdSet"; readonly idSet: ReadonlySet<b.BrandId> };
} | {
  readonly resourceName: "Account";
  readonly target:
    | { readonly type: "filter"; readonly filter: f.AccountFilter }
    | { readonly type: "byIdSet"; readonly idSet: ReadonlySet<b.AccountId> }
    | { readonly type: "one"; readonly name: "MyAccount" };
} | {
  readonly resourceName: "AccountPrivate";
  readonly target: {
    readonly type: "byIdSet";
    readonly idSet: ReadonlySet<b.AccountId>;
  };
} | {
  readonly resourceName: "Designer";
  readonly target: {
    readonly type: "byIdSet";
    readonly idSet: ReadonlySet<b.DesignerId>;
  };
} | {
  readonly resourceName: "Item";
  readonly target:
    | { readonly type: "filter"; readonly filter: f.ItemFilter }
    | { readonly type: "byIdSet"; readonly idSet: ReadonlySet<b.ItemId> };
} | {
  readonly resourceName: "ItemImage";
  readonly target: {
    readonly type: "byIdSet";
    readonly idSet: ReadonlySet<b.ItemId>;
  };
} | {
  readonly resourceName: "ItemEvent";
  readonly target: {
    readonly type: "filter";
    readonly filter: f.ItemEventFilter;
  } | { readonly type: "byIdSet"; readonly idSet: ReadonlySet<b.ItemEventId> };
} | {
  readonly resourceName: "ItemEventType";
  readonly target: {
    readonly type: "filter";
    readonly filter: f.ItemEventTypeFilter;
  } | {
    readonly type: "byIdSet";
    readonly idSet: ReadonlySet<b.ItemEventTypeId>;
  };
};

/**
 * データを取得する関数を呼ぶように予定を立てる
 */
export const schedule = (state: CommectionState): void => {
  if (state[scheduledSymbol]) {
    return;
  }
  state[scheduledSymbol] = true;
  setTimeout((): void => {
    requestIfNeed(state);
    state[scheduledSymbol] = false;
  }, 100);
};

/**
 * リクエストが必要ならリクエストする
 */
const requestIfNeed = (state: CommectionState): void => {
  a.scanWaitForRequest(
    state.collectionStore,
    (idSet) => (g.getCollectionByIdSet(idSet, state.bearerToken)),
    (
      filterString,
    ) => (g.getCollectionListByFilter(
      h.collectionFilterFromSearchParams(new URLSearchParams(filterString)),
      state.bearerToken,
    )),
  );
  a.scanWaitForRequest(
    state.brandStore,
    (idSet) => (g.getBrandByIdSet(idSet, state.bearerToken)),
    (
      filterString,
    ) => (g.getBrandListByFilter(
      h.brandFilterFromSearchParams(new URLSearchParams(filterString)),
      state.bearerToken,
    )),
  );
  a.scanWaitForRequest(
    state.accountStore,
    (idSet) => (g.getAccountByIdSet(idSet, state.bearerToken)),
    (
      filterString,
    ) => (g.getAccountListByFilter(
      h.accountFilterFromSearchParams(new URLSearchParams(filterString)),
      state.bearerToken,
    )),
  );
  a.scanWaitForRequestOne(
    state.myAccount,
    () => (g.getMyAccount(state.bearerToken)),
  );
  a.scanWaitForRequestByIds(
    state.accountPrivateAndCallbacksMap,
    (idSet) => (g.getAccountPrivateByIdSet(idSet, state.bearerToken)),
  );
  a.scanWaitForRequestByIds(
    state.designerAndCallbacksMap,
    (idSet) => (g.getDesignerByIdSet(idSet, state.bearerToken)),
  );
  a.scanWaitForRequest(
    state.itemStore,
    (idSet) => (g.getItemByIdSet(idSet, state.bearerToken)),
    (
      filterString,
    ) => (g.getItemListByFilter(
      h.itemFilterFromSearchParams(new URLSearchParams(filterString)),
      state.bearerToken,
    )),
  );
  a.scanWaitForRequestByIds(
    state.itemImageAndCallbacksMap,
    (idSet) => (g.getItemImageByIdSet(idSet, state.bearerToken)),
  );
  a.scanWaitForRequest(
    state.itemEventStore,
    (idSet) => (g.getItemEventByIdSet(idSet, state.bearerToken)),
    (
      filterString,
    ) => (g.getItemEventListByFilter(
      h.itemEventFilterFromSearchParams(new URLSearchParams(filterString)),
      state.bearerToken,
    )),
  );
  a.scanWaitForRequest(
    state.itemEventTypeStore,
    (idSet) => (g.getItemEventTypeByIdSet(idSet, state.bearerToken)),
    (
      filterString,
    ) => (g.getItemEventTypeListByFilter(
      h.itemEventTypeFilterFromSearchParams(new URLSearchParams(filterString)),
      state.bearerToken,
    )),
  );
};

export const callbacksAndDataStateMapSubscribe = <
  Key extends unknown,
  Resource extends unknown,
>(
  parameter: {
    readonly state: CommectionState;
    readonly callbacksAndDataStateMap: e.CallbacksAndDataStateMap<
      Key,
      Resource
    >;
    readonly key: Key;
    readonly onStoreChange: () => void;
  },
): () => void => {
  schedule(parameter.state);
  e.addCallbackInMap(
    parameter.callbacksAndDataStateMap,
    parameter.key,
    parameter.onStoreChange,
  );
  const unsubscribe: () => void = (): void => {
    e.deleteCallbackInMap(
      parameter.callbacksAndDataStateMap,
      parameter.key,
      parameter.onStoreChange,
    );
  };
  return unsubscribe;
};
