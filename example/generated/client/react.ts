/** generated by
 * - commection in unloss
 * - https://jsr.io/@narumincho/js-ts-code-generator@0.8.2
 * Do not edit!
 *
 * @module
 */

import * as a from "react";
import * as b from "./subscribe.ts";
import * as c from "../../commection/runtime/client/callbacksAndDataStateMap.ts";
import * as d from "../../commection/runtime/client/react.ts";
import * as e from "../../commection/runtime/client/dataState.ts";
import * as f from "../../common/id.ts";
import * as g from "../../common/type.ts";
import * as h from "../../common/filterType.ts";
import * as i from "../../common/filterSearchParamsCodec.ts";
import * as j from "../../commection/runtime/client/store.ts";

/**
 * commection のデータの保管庫を作る.
 * storybookのようなコンポーネントのサンプルデータを表示するために分けることもできる
 */
const CommectionContext = a.createContext<b.CommectionState | undefined>(
  undefined,
);

/**
 * commection のデータの保管庫を作る.
 *
 * storybookのようなコンポーネントのサンプルデータを表示するために分けることもできる
 */
export const CommectionProvider = (
  props: {
    readonly bearerToken: string | undefined;
    readonly children: a.ReactNode;
  },
) => {
  const ref = a.useRef(b.createCommectionState(props.bearerToken));
  a.useEffect(() => {
    if (ref.current.bearerToken !== props.bearerToken) {
      ref.current = b.createCommectionState(props.bearerToken);
    }
  }, [props.bearerToken]);
  return a.createElement(
    CommectionContext.Provider,
    { value: ref.current },
    props.children,
  );
};

export const useCommection = (): b.CommectionState => {
  const state = a.useContext(CommectionContext);
  if (!state) {
    throw new Error(
      "need <CommectionProvider><Component /><CommectionProvider>",
    );
  }
  return state;
};

/**
 * @param id ID 未指定であればリクエストは送られない
 */
const useResource = <Id extends string, Resource extends unknown>(
  id: Id | undefined,
  state: b.CommectionState,
  callbacksAndDataStateMap: c.CallbacksAndDataStateMap<Id, Resource>,
): d.HookResult<Resource> => {
  const subscribe = a.useCallback(
    (onStoreChange: () => void) => (id
      ? b.callbacksAndDataStateMapSubscribe({
        state,
        callbacksAndDataStateMap,
        key: id,
        onStoreChange,
      })
      : () => {
      }),
    [id, callbacksAndDataStateMap],
  );
  const dataState = a.useSyncExternalStore(subscribe, () => {
    if (!id) {
      return e.dataStateNone;
    }
    return c.getDataStateInMap(callbacksAndDataStateMap, id);
  });
  const refetch = a.useCallback(() => {
    if (id) {
      c.setWaitForRequest(callbacksAndDataStateMap, id);
      b.schedule(state);
    }
  }, [id, callbacksAndDataStateMap]);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * ```ts
 * useCollection('a')
 * useCollection('b')
 * useCollection('c')
 * useCollection('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/collection?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useCollection = (
  id: f.CollectionId | undefined,
): d.HookResult<g.Collection> => {
  const state = useCommection();
  const result = useResource(id, state, state.collectionStore.itemById);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Collection を取得しその ID を配列として返す.
 *
 * IDを返すので Resource のデータが変わっても IDが変わらなければ再レンダリングされない
 * @param filter フィルター
 */
export const useCollectionIds = (
  filter: h.CollectionFilter,
): d.HookResult<ReadonlyArray<f.CollectionId>> => {
  const state = useCommection();
  const filterString = i.collectionFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.collectionStore.idsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(
      state.collectionStore.idsByFilter,
      filterString,
    )),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.collectionStore.idsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Collection を取得し配列として返す.
 *
 * どれか1つでもResource のデータが変わったら再レンダリングされるので, 並び替えや集計処理をしないのなら {@link useCollectionIds}を使うことをおすすめします
 * @param filter フィルター
 */
export const useCollectionArray = (
  filter: h.CollectionFilter,
): d.HookResult<
  ReadonlyArray<j.ItemsByFilterItem<f.CollectionId, g.Collection>>
> => {
  const state = useCommection();
  const filterString = i.collectionFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.collectionStore.itemsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(
      state.collectionStore.itemsByFilter,
      filterString,
    )),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.collectionStore.itemsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * ```ts
 * useBrand('a')
 * useBrand('b')
 * useBrand('c')
 * useBrand('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/brand?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useBrand = (id: f.BrandId | undefined): d.HookResult<g.Brand> => {
  const state = useCommection();
  const result = useResource(id, state, state.brandStore.itemById);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Brand を取得しその ID を配列として返す.
 *
 * IDを返すので Resource のデータが変わっても IDが変わらなければ再レンダリングされない
 * @param filter フィルター
 */
export const useBrandIds = (
  filter: h.BrandFilter,
): d.HookResult<ReadonlyArray<f.BrandId>> => {
  const state = useCommection();
  const filterString = i.brandFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.brandStore.idsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(state.brandStore.idsByFilter, filterString)),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.brandStore.idsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Brand を取得し配列として返す.
 *
 * どれか1つでもResource のデータが変わったら再レンダリングされるので, 並び替えや集計処理をしないのなら {@link useBrandIds}を使うことをおすすめします
 * @param filter フィルター
 */
export const useBrandArray = (
  filter: h.BrandFilter,
): d.HookResult<ReadonlyArray<j.ItemsByFilterItem<f.BrandId, g.Brand>>> => {
  const state = useCommection();
  const filterString = i.brandFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.brandStore.itemsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(state.brandStore.itemsByFilter, filterString)),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.brandStore.itemsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * ```ts
 * useAccount('a')
 * useAccount('b')
 * useAccount('c')
 * useAccount('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/account?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useAccount = (
  id: f.AccountId | undefined,
): d.HookResult<g.Account> => {
  const state = useCommection();
  const result = useResource(id, state, state.accountStore.itemById);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Account を取得しその ID を配列として返す.
 *
 * IDを返すので Resource のデータが変わっても IDが変わらなければ再レンダリングされない
 * @param filter フィルター
 */
export const useAccountIds = (
  filter: h.AccountFilter,
): d.HookResult<ReadonlyArray<f.AccountId>> => {
  const state = useCommection();
  const filterString = i.accountFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.accountStore.idsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(state.accountStore.idsByFilter, filterString)),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.accountStore.idsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Account を取得し配列として返す.
 *
 * どれか1つでもResource のデータが変わったら再レンダリングされるので, 並び替えや集計処理をしないのなら {@link useAccountIds}を使うことをおすすめします
 * @param filter フィルター
 */
export const useAccountArray = (
  filter: h.AccountFilter,
): d.HookResult<ReadonlyArray<j.ItemsByFilterItem<f.AccountId, g.Account>>> => {
  const state = useCommection();
  const filterString = i.accountFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.accountStore.itemsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(state.accountStore.itemsByFilter, filterString)),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.accountStore.itemsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * ```ts
 * useAccountPrivate('a')
 * useAccountPrivate('b')
 * useAccountPrivate('c')
 * useAccountPrivate('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/accountPrivate?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useAccountPrivate = (
  id: f.AccountId | undefined,
): d.HookResult<g.AccountPrivate> => {
  const state = useCommection();
  const result = useResource(id, state, state.accountPrivateAndCallbacksMap);
  return result;
};

/**
 * ```ts
 * useDesigner('a')
 * useDesigner('b')
 * useDesigner('c')
 * useDesigner('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/designer?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useDesigner = (
  id: f.DesignerId | undefined,
): d.HookResult<g.Designer> => {
  const state = useCommection();
  const result = useResource(id, state, state.designerAndCallbacksMap);
  return result;
};

/**
 * ```ts
 * useItem('a')
 * useItem('b')
 * useItem('c')
 * useItem('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/item?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useItem = (id: f.ItemId | undefined): d.HookResult<g.Item> => {
  const state = useCommection();
  const result = useResource(id, state, state.itemStore.itemById);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Item を取得しその ID を配列として返す.
 *
 * IDを返すので Resource のデータが変わっても IDが変わらなければ再レンダリングされない
 * @param filter フィルター
 */
export const useItemIds = (
  filter: h.ItemFilter,
): d.HookResult<ReadonlyArray<f.ItemId>> => {
  const state = useCommection();
  const filterString = i.itemFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.itemStore.idsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(state.itemStore.idsByFilter, filterString)),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.itemStore.idsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * 指定したフィルターの条件を満たす Item を取得し配列として返す.
 *
 * どれか1つでもResource のデータが変わったら再レンダリングされるので, 並び替えや集計処理をしないのなら {@link useItemIds}を使うことをおすすめします
 * @param filter フィルター
 */
export const useItemArray = (
  filter: h.ItemFilter,
): d.HookResult<ReadonlyArray<j.ItemsByFilterItem<f.ItemId, g.Item>>> => {
  const state = useCommection();
  const filterString = i.itemFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.itemStore.itemsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(state.itemStore.itemsByFilter, filterString)),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.itemStore.itemsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * ```ts
 * useItemImage('a')
 * useItemImage('b')
 * useItemImage('c')
 * useItemImage('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/itemImage?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useItemImage = (
  id: f.ItemId | undefined,
): d.HookResult<g.ItemImage> => {
  const state = useCommection();
  const result = useResource(id, state, state.itemImageAndCallbacksMap);
  return result;
};

/**
 * ```ts
 * useItemEvent('a')
 * useItemEvent('b')
 * useItemEvent('c')
 * useItemEvent('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/itemEvent?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useItemEvent = (
  id: f.ItemEventId | undefined,
): d.HookResult<g.ItemEvent> => {
  const state = useCommection();
  const result = useResource(id, state, state.itemEventStore.itemById);
  return result;
};

/**
 * 指定したフィルターの条件を満たす ItemEvent を取得しその ID を配列として返す.
 *
 * IDを返すので Resource のデータが変わっても IDが変わらなければ再レンダリングされない
 * @param filter フィルター
 */
export const useItemEventIds = (
  filter: h.ItemEventFilter,
): d.HookResult<ReadonlyArray<f.ItemEventId>> => {
  const state = useCommection();
  const filterString = i.itemEventFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.itemEventStore.idsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(state.itemEventStore.idsByFilter, filterString)),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.itemEventStore.idsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * 指定したフィルターの条件を満たす ItemEvent を取得し配列として返す.
 *
 * どれか1つでもResource のデータが変わったら再レンダリングされるので, 並び替えや集計処理をしないのなら {@link useItemEventIds}を使うことをおすすめします
 * @param filter フィルター
 */
export const useItemEventArray = (
  filter: h.ItemEventFilter,
): d.HookResult<
  ReadonlyArray<j.ItemsByFilterItem<f.ItemEventId, g.ItemEvent>>
> => {
  const state = useCommection();
  const filterString = i.itemEventFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.itemEventStore.itemsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(
      state.itemEventStore.itemsByFilter,
      filterString,
    )),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.itemEventStore.itemsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * ```ts
 * useItemEventType('a')
 * useItemEventType('b')
 * useItemEventType('c')
 * useItemEventType('c')
 * ```
 * は
 * ```ts
 * await fetch('/commection/itemEventType?id=a&id=b&id=c')
 * ```
 *
 * のようにまとめてリクエストを送られる
 *
 * @param id ID 未指定であればリクエストは送られない
 */
export const useItemEventType = (
  id: f.ItemEventTypeId | undefined,
): d.HookResult<g.ItemEventType> => {
  const state = useCommection();
  const result = useResource(id, state, state.itemEventTypeStore.itemById);
  return result;
};

/**
 * 指定したフィルターの条件を満たす ItemEventType を取得しその ID を配列として返す.
 *
 * IDを返すので Resource のデータが変わっても IDが変わらなければ再レンダリングされない
 * @param filter フィルター
 */
export const useItemEventTypeIds = (
  filter: h.ItemEventTypeFilter,
): d.HookResult<ReadonlyArray<f.ItemEventTypeId>> => {
  const state = useCommection();
  const filterString = i.itemEventTypeFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.itemEventTypeStore.idsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(
      state.itemEventTypeStore.idsByFilter,
      filterString,
    )),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.itemEventTypeStore.idsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};

/**
 * 指定したフィルターの条件を満たす ItemEventType を取得し配列として返す.
 *
 * どれか1つでもResource のデータが変わったら再レンダリングされるので, 並び替えや集計処理をしないのなら {@link useItemEventTypeIds}を使うことをおすすめします
 * @param filter フィルター
 */
export const useItemEventTypeArray = (
  filter: h.ItemEventTypeFilter,
): d.HookResult<
  ReadonlyArray<j.ItemsByFilterItem<f.ItemEventTypeId, g.ItemEventType>>
> => {
  const state = useCommection();
  const filterString = i.itemEventTypeFilterToSearchParams(filter).toString();
  const subscribe = a.useCallback(
    (
      onStoreChange: () => void,
    ) => (b.callbacksAndDataStateMapSubscribe({
      state,
      callbacksAndDataStateMap: state.itemEventTypeStore.itemsByFilter,
      key: filterString,
      onStoreChange,
    })),
    [filterString, state],
  );
  const dataState = a.useSyncExternalStore(
    subscribe,
    () => (c.getDataStateInMap(
      state.itemEventTypeStore.itemsByFilter,
      filterString,
    )),
  );
  const refetch = a.useCallback(() => {
    c.setWaitForRequest(state.itemEventTypeStore.itemsByFilter, filterString);
    b.schedule(state);
  }, []);
  const result = a.useMemo(() => ({ dataState, refetch }), [
    dataState,
    refetch,
  ]);
  return result;
};
