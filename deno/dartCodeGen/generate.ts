import { divideList } from "../listUtil.ts";
import {
  ClassDeclaration,
  DartCode,
  Declaration,
  EnumDeclaration,
  EnumValue,
  Expr,
  ImportPackageFileNameAndAsName,
  Method,
  Operator,
  Parameter,
  Statement,
  StaticField,
  StringLiteralItem,
  Type,
} from "./type.ts";

export const generateDartCode = (dartCode: DartCode): string => {
  const importPackageFileNameAndAsNameList = divideList(
    [
      {
        packageAndFileName: "package:meta/meta.dart",
        asName: undefined,
      },
      {
        packageAndFileName:
          "package:fast_immutable_collections/fast_immutable_collections.dart",
        asName: undefined,
      },
      ...dartCode.importPackageAndFileNames,
    ].sort((a, b) =>
      comparePackageName(a.packageAndFileName, b.packageAndFileName)
    ),
    (item) => item.packageAndFileName.startsWith("./")
  );
  const importStatementAbsolute = importPackageFileNameAndAsNameList.true
    .map((n) => toImportStatementCodeString(n))
    .join("\n");
  const importStatementRelative = importPackageFileNameAndAsNameList.false
    .map((n) => toImportStatementCodeString(n))
    .join("\n");
  const declarationListCode = dartCode.declarationList
    .map(declarationToCodeString)
    .join("\n\n");

  const code = `// Generated by commection. Do not edit.
// ignore_for_file: camel_case_types, constant_identifier_names, always_use_package_imports
${importStatementAbsolute}

${importStatementRelative}

${declarationListCode}
`;
  return code;
};

const comparePackageName = (a: string, b: string): number => {
  const aIsLocal = a.startsWith("./");
  const bIsLocal = b.startsWith("./");
  if (aIsLocal && !bIsLocal) {
    return -1;
  }
  if (!aIsLocal && bIsLocal) {
    return 1;
  }
  return a.localeCompare(b);
};

const toImportStatementCodeString = (
  importPackageFileNameAndAsName: ImportPackageFileNameAndAsName
): string => {
  return (
    "import '" +
    importPackageFileNameAndAsName.packageAndFileName +
    "'" +
    (importPackageFileNameAndAsName.asName == null
      ? ""
      : "as " + importPackageFileNameAndAsName.asName) +
    ";"
  );
};

const declarationToCodeString = (declaration: Declaration): string => {
  switch (declaration.type) {
    case "ClassDeclaration":
      return classDeclarationToCodeString(declaration);
    case "EnumDeclaration":
      return enumDeclarationToCodeString(declaration);
  }
};

const classDeclarationToCodeString = (
  classDeclaration: ClassDeclaration
): string => {
  const methods = [
    ...(classDeclaration.modifier === "final" ||
    classDeclaration.modifier === undefined
      ? []
      : []),
    ...classDeclaration.methods,
  ];

  return (
    documentationCommentsToCodeString(classDeclaration.documentationComments) +
    "@immutable\n" +
    (classDeclaration.modifier === undefined
      ? ""
      : classDeclaration.modifier + " ") +
    "class " +
    classDeclaration.name +
    " " +
    (classDeclaration.implementsClassList.length === 0
      ? ""
      : "implements " + classDeclaration.implementsClassList.join(" ") + " ") +
    "{\n" +
    documentationCommentsToCodeString(classDeclaration.documentationComments) +
    "  const " +
    classDeclaration.name +
    (classDeclaration.isPrivateConstructor ? "._" : "") +
    parametersToCodeString(true, classDeclaration.fields) +
    ";\n" +
    classDeclaration.fields
      .map(
        (field) =>
          documentationCommentsToCodeString(field.documentationComments) +
          "  final ${field.type.toCodeString()} ${field.name};\n\n"
      )
      .join("") +
    classDeclaration.staticFields
      .map((field) => staticFieldToCodeString(field))
      .join("") +
    methods.map(methodToCodeString).join("") +
    "\n}"
  );
};

const parametersToCodeString = (
  isConstructor: boolean,
  parameters: ReadonlyArray<Parameter>
): string => {
  const namedCode = parameters
    .flatMap((parameter) => {
      const code = positionalArgumentToCodeString(parameter, isConstructor);
      if (code === undefined) return [];
      return [code];
    })
    .join(",");
  const positionalCodeList = parameters.flatMap((parameter) => {
    const code = namedArgumentToCodeString(parameter, isConstructor);
    if (code === undefined) {
      return [];
    }
    return [code];
  });
  return (
    "(" +
    namedCode +
    (positionalCodeList.length === 0
      ? ""
      : "{" + positionalCodeList.join(",") + "}") +
    ")"
  );
};

const positionalArgumentToCodeString = (
  parameter: Parameter,
  isConstructor: boolean
): string | undefined => {
  switch (parameter.parameterPattern.type) {
    case "Positional":
      return nameWithThis(parameter.type, parameter.name, isConstructor);
    case "Named":
    case "NamedWithDefault":
      return undefined;
  }
};

const namedArgumentToCodeString = (
  parameter: Parameter,
  isConstructor: boolean
): string | undefined => {
  switch (parameter.parameterPattern.type) {
    case "Positional":
      return undefined;
    case "Named":
      return (
        "required " +
        nameWithThis(parameter.type, parameter.name, isConstructor)
      );
    case "NamedWithDefault":
      return (
        nameWithThis(parameter.type, parameter.name, isConstructor) +
        (parameter.parameterPattern.constDefaultExpr.type === "Null"
          ? ""
          : " = " +
            exprToCodeString(parameter.parameterPattern.constDefaultExpr))
      );
  }
};

const nameWithThis = (type: Type, name: string, isConstructor: boolean) => {
  if (isConstructor) {
    return "this." + name;
  }
  return typeToCodeString(type) + name;
};

const staticFieldToCodeString = (staticField: StaticField): string => {
  const toCodeAndConstType = exprToCodeString(staticField.expr);
  return (
    documentationCommentsToCodeString(staticField.documentationComments) +
    " static " +
    (constTypeIsConst(toCodeAndConstType.constType) ? "const " : "") +
    typeToCodeString(staticField.type) +
    " " +
    staticField.name +
    " = " +
    toCodeAndConstType.code +
    ";\n"
  );
};

const methodToCodeString = (method: Method): string => {
  return (
    documentationCommentsToCodeString(method.documentationComments) +
    (method.methodType == "override" ? "@override\n" : "") +
    (method.useResultAnnotation ? "@useResult\n" : "") +
    (method.methodType == "static" ? "static " : "") +
    typeToCodeString(method.returnType) +
    " " +
    (method.isGetter ? "get " : "") +
    methodNameConsiderOperator(method.name) +
    (method.typeParameters.length === 0
      ? ""
      : "<" + stringListJoinWithComma(method.typeParameters) + ">") +
    (method.isGetter ? "" : parametersToCodeString(false, method.parameters)) +
    (method.statements.length === 0
      ? ";\n"
      : (method.isAsync ? " async" : "") +
        " {\n" +
        method.statements.map(statementToCodeString).join("") +
        "\n}")
  );
};

const methodNameConsiderOperator = (name: string) => {
  if (name == "==") {
    return "operator ==";
  }
  return name;
};

const typeToCodeString = (type: Type): string => {
  switch (type.type) {
    case "Function":
      return (
        typeToCodeString(type.returnType) +
        " Function(" +
        type.parameters
          .map(
            (parameter) =>
              typeToCodeString(parameter.type) + " " + parameter.name
          )
          .join(",") +
        ")" +
        (type.isNullable ? "?" : "")
      );
    case "Normal":
      return (
        type.name +
        (type.arguments.length === 0
          ? ""
          : "<" +
            type.arguments
              .map((argument) => typeToCodeString(argument))
              .join(", ") +
            ">") +
        (type.isNullable ? "?" : "")
      );
  }
};

const statementToCodeString = (statement: Statement): string => {
  switch (statement.type) {
    case "Return":
      return (
        "return " + toCodeString(exprToCodeString(statement.expr), true) + ";\n"
      );
    case "Final": {
      const codeAndConstType = exprToCodeString(statement.expr);
      return constTypeIsConst(codeAndConstType.constType)
        ? "const "
        : "final" +
            " " +
            statement.variableName +
            " = " +
            codeAndConstType.code +
            "\n;";
    }
    case "If":
      return (
        "if (" +
        toCodeString(exprToCodeString(statement.condition), true) +
        ") {\n" +
        statement.thenStatement.map(statementToCodeString).join("") +
        "}"
      );
    case "Switch":
      return (
        "switch (" +
        toCodeString(exprToCodeString(statement.expr), true) +
        ") {\n" +
        statement.patternList
          .map(
            (pattern) =>
              "case " +
              toCodeString(exprToCodeString(pattern.pattern), true) +
              ": {\n" +
              pattern.statements.map(statementToCodeString).join("") +
              "\n}\n"
          )
          .join("\n") +
        "}\n"
      );
    case "Throw":
      return (
        "throw " + toCodeString(exprToCodeString(statement.expr), true) + ";\n"
      );
  }
};

const exprToCodeString = (expr: Expr): CodeAndConstType => {
  switch (expr.type) {
    case "IntLiteral":
      return { code: expr.value.toString(), constType: "implicit" };
    case "StringLiteral": {
      const codeAndConstTypeList = expr.items.map((item) =>
        stringLiteralItemToCodeAndConstType(item)
      );
      const isAllConst = codeAndConstTypeList.every((item) =>
        constTypeIsConst(item.constType)
      );
      return {
        code:
          "'" + codeAndConstTypeList.map((item) => item.code).join("") + "'",
        constType: isAllConst ? "implicit" : "noConst",
      };
    }
    case "EnumValue":
      return { code: expr.typeName + "." + expr.value, constType: "implicit" };
    case "MethodCall":
      return {
        code:
          toCodeString(exprToCodeString(expr.variable), true) +
          (expr.optionalChaining ? "?" : "") +
          "." +
          expr.methodName +
          argumentsToCodeAndConstType(
            expr.positionalArguments,
            expr.namedArguments
          ).code,
        constType: "noConst",
      };
    case "Constructor": {
      const argumentsCodeAndConstType = argumentsToCodeAndConstType(
        expr.positionalArguments,
        expr.namedArguments
      );
      return {
        code: expr.className + argumentsCodeAndConstType.code,
        constType:
          expr.isConst && constTypeIsConst(argumentsCodeAndConstType.constType)
            ? "explicit"
            : "noConst",
      };
    }
    case "Lambda": {
      return {
        code:
          "(" +
          expr.parameterNames.join(",") +
          ") {\n " +
          expr.statements.map(statementToCodeString).join("") +
          "\n}",
        constType: "noConst",
      };
    }
    case "ListLiteral": {
      const codeAndConstTypeList = expr.items.map((item) =>
        exprToCodeString(item)
      );
      const isAllConst = codeAndConstTypeList.every((item) =>
        constTypeIsConst(item.constType)
      );
      return {
        code:
          "[" +
          stringListJoinWithComma(
            codeAndConstTypeList.map((item) => toCodeString(item, !isAllConst))
          ) +
          "]",
        constType: isAllConst ? "explicit" : "noConst",
      };
    }
    case "MapLiteral": {
      const codeAndConstTypeList = expr.items.map((item) => ({
        key: exprToCodeString(item.key),
        value: exprToCodeString(item.value),
      }));
      const isAllConst = codeAndConstTypeList.every(
        (item) =>
          constTypeIsConst(item.key.constType) &&
          constTypeIsConst(item.value.constType)
      );
      return {
        code:
          "{" +
          stringListJoinWithComma(
            codeAndConstTypeList.map((item) => {
              const key = toCodeString(item.key, !isAllConst);
              const value = toCodeString(item.value, !isAllConst);
              return key + ":" + value;
            })
          ) +
          "}",
        constType: isAllConst ? "explicit" : "noConst",
      };
    }
    case "Variable":
      return {
        code: expr.name,
        constType: expr.isConst ? "implicit" : "noConst",
      };
    case "Get":
      return {
        code:
          toCodeString(exprToCodeString(expr.expr), true) +
          "." +
          expr.fieldName,
        constType: "noConst",
      };
    case "Is":
      return {
        code:
          "(" +
          toCodeString(exprToCodeString(expr.expr), true) +
          " is " +
          expr.type +
          ")",
        constType: "noConst",
      };
    case "Operator":
      return {
        code:
          "(" +
          toCodeString(exprToCodeString(expr.left), true) +
          " " +
          operatorToCodeString(expr.operator) +
          " " +
          toCodeString(exprToCodeString(expr.right), true) +
          ")",
        constType: "noConst",
      };
    case "Null":
      return {
        code: "null",
        constType: "implicit",
      };
    case "Bool":
      return {
        code: expr.value ? "true" : "false",
        constType: "implicit",
      };
    case "ConditionalOperator":
      return {
        code:
          "(" +
          toCodeString(exprToCodeString(expr.condition), true) +
          " ? " +
          toCodeString(exprToCodeString(expr.thenExpr), true) +
          " : " +
          toCodeString(exprToCodeString(expr.elseExpr), true) +
          ")",
        constType: "noConst",
      };
    case "Call":
      return {
        code:
          (expr.isAwait ? "await " : "") +
          expr.functionName +
          argumentsToCodeAndConstType(
            expr.positionalArguments,
            expr.namedArguments
          ).code,
        constType: "noConst",
      };
  }
};

const stringLiteralItemToCodeAndConstType = (
  stringLiteralItem: StringLiteralItem
): CodeAndConstType => {
  switch (stringLiteralItem.type) {
    case "Normal":
      return {
        code: stringLiteralItem.value
          .replaceAll("\\", "\\\\")
          .replaceAll("$", "\\$")
          .replaceAll("\n", "\\n")
          .replaceAll("'", "\\'"),
        constType: "implicit",
      };
    case "Interpolation": {
      const codeAndConstType = exprToCodeString(stringLiteralItem.expr);
      return {
        code: "${" + codeAndConstType.code + "}",
        constType: codeAndConstType.constType,
      };
    }
  }
};

export type CodeAndConstType = {
  readonly code: string;
  readonly constType: ConstType;
};

const toCodeString = (
  codeAndConstType: CodeAndConstType,
  /**
   * 全体として const ではない (const を出力する) なら true
   */
  isLimit: boolean
): string => {
  return (
    (codeAndConstType.constType == "explicit" && isLimit ? "const " : "") +
    codeAndConstType.code
  );
};

export type ConstType = "noConst" | "implicit" | "explicit";

const constTypeIsConst = (constType: ConstType): boolean =>
  constType != "noConst";

const stringListJoinWithComma = (list: ReadonlyArray<string>): string => {
  if (list.length === 0) {
    return "";
  }
  const first = list[0];
  if (first !== undefined && list.length === 1) {
    return first;
  }
  return list.map((item) => item + ",").join("");
};

const documentationCommentsSlash = "///";

const documentationCommentsToCodeString = (
  documentationComments: string
): string => {
  const trimmed = documentationComments.trim();
  if (trimmed.length === 0) {
    return "";
  }
  return documentationComments
    .split("\n")
    .map((line) => {
      if (line.trim().length === 0) {
        return documentationCommentsSlash + "\n";
      }
      return documentationCommentsSlash + " " + line.trimEnd() + "\n";
    })
    .join();
};

const enumDeclarationToCodeString = (
  enumDeclaration: EnumDeclaration
): string => {
  return (
    documentationCommentsToCodeString(enumDeclaration.documentationComments) +
    "enum " +
    enumDeclaration.name +
    (enumDeclaration.implementsClassList.length === 0
      ? ""
      : " implements " + enumDeclaration.implementsClassList.join(",")) +
    " {\n" +
    enumDeclaration.enumValues
      .map((enumValue) => enumValueToCodeString(enumValue))
      .join("\n") +
    (enumDeclaration.methods.length === 0
      ? ""
      : ";" +
        enumDeclaration.methods
          .map((method) => methodToCodeString(method))
          .join("\n")) +
    "}"
  );
};

const enumValueToCodeString = (enumValue: EnumValue): string => {
  return (
    documentationCommentsToCodeString(enumValue.documentationComments) +
    "  " +
    enumValue.name +
    ",\n"
  );
};

const argumentsToCodeAndConstType = (
  positionalArguments: ReadonlyArray<Expr>,
  namedArguments: ReadonlyArray<{
    readonly name: string;
    readonly expr: Expr;
  }>
): CodeAndConstType => {
  const positionalCodeAndConstTypeList = positionalArguments.map((expr) =>
    exprToCodeString(expr)
  );
  const namedCodeAndConstTypeList = namedArguments.map((namedArgument) => ({
    name: namedArgument.name,
    codeAndConstType: exprToCodeString(namedArgument.expr),
  }));
  const isAllConst =
    positionalCodeAndConstTypeList.every((item) =>
      constTypeIsConst(item.constType)
    ) &&
    namedCodeAndConstTypeList.every((argument) =>
      constTypeIsConst(argument.codeAndConstType.constType)
    );
  return {
    code:
      "(" +
      stringListJoinWithComma([
        ...positionalCodeAndConstTypeList.map((argument) =>
          toCodeString(argument, !isAllConst)
        ),
        ...namedCodeAndConstTypeList.map(
          (argument) =>
            argument.name +
            ": " +
            toCodeString(argument.codeAndConstType, !isAllConst)
        ),
      ]),
    constType: isAllConst ? "explicit" : "noConst",
  };
};

const operatorToCodeString = (operator: Operator): string => {
  switch (operator) {
    case "nullishCoalescing":
      return "??";
    case "notEqual":
      return "!=";
    case "equal":
      return "==";
    case "add":
      return "+";
    case "logicalAnd":
      return "&&";
  }
};
