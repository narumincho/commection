use std::vec;

use non_empty_string::NonEmptyString;

use crate::dart::data;

pub fn generate(code: &data::Code) -> String {
    let import_package_and_file_names = vec![
        data::ImportPackageAndFileName {
            package_and_file_name: NonEmptyString::new("package:meta/meta.dart".to_string())
                .unwrap(),
            as_name: None,
        },
        data::ImportPackageAndFileName {
            package_and_file_name: NonEmptyString::new(
                "package:fast_immutable_collections/fast_immutable_collections.dart".to_string(),
            )
            .unwrap(),
            as_name: None,
        },
    ];
    let mut li = import_package_and_file_names
        .iter()
        .collect::<Vec<&data::ImportPackageAndFileName>>();
    for import_package_and_file_name in &code.import_package_and_file_names {
        li.push(import_package_and_file_name.clone());
    }
    li.sort();
    let import_package_file_name_and_as_name_list =
        crate::list_util::divide_list(li, |import_package_and_file_name| {
            import_package_and_file_name
                .package_and_file_name
                .to_string()
                .starts_with("./")
        });
    let import_statement_relative = import_package_file_name_and_as_name_list
        .0
        .iter()
        .map(|import_package_and_file_name| {
            to_import_statement_code_string(import_package_and_file_name)
        })
        .collect::<Vec<String>>()
        .join("\n");
    let import_statement_absolute = import_package_file_name_and_as_name_list
        .1
        .iter()
        .map(|import_package_and_file_name| {
            to_import_statement_code_string(import_package_and_file_name)
        })
        .collect::<Vec<String>>()
        .join("\n");

    let declaration_list_code = code
        .declaration_list
        .iter()
        .map(|declaration| declaration_to_code_string(declaration))
        .collect::<Vec<String>>()
        .join("\n\n");

    format!(
        "// Generated by commection. Do not edit.
// ignore_for_file: camel_case_types, constant_identifier_names, always_use_package_imports
{}

{}

{}
",
        import_statement_absolute, import_statement_relative, declaration_list_code
    )
}

fn to_import_statement_code_string(
    import_package_and_file_name: &data::ImportPackageAndFileName,
) -> String {
    String::from("import '")
        + &import_package_and_file_name
            .package_and_file_name
            .to_string()
        + &"'"
        + &(match &import_package_and_file_name.as_name {
            Some(as_name) => " as ".to_string() + &as_name.to_string(),
            None => "".to_string(),
        })
        + &";"
}

fn declaration_to_code_string(declaration: &data::Declaration) -> String {
    match declaration {
        data::Declaration::Class(class_declaration) => {
            class_declaration_to_code_string(class_declaration)
        }
        data::Declaration::Enum(enum_declaration) => {
            enum_declaration_to_code_string(enum_declaration)
        }
    }
}

fn class_declaration_to_code_string(class_declaration: &data::ClassDeclaration) -> String {
    let methods = class_declaration.methods;
}

fn enum_declaration_to_code_string(enum_declaration: &data::EnumDeclaration) -> String {}

fn documentation_comments_to_code_string(documentation_comments: &String) -> String {
    documentation_comments
        .lines()
        .map(|line| {
            if line.trim().is_empty() {
                "///\n".to_string()
            } else {
                "/// ".to_string() + line + "\n"
            }
        })
        .collect::<Vec<String>>()
        .join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate() {
        let code = data::Code {
            import_package_and_file_names: vec![],
            declaration_list: vec![],
        };
        let actual = generate(&code);
        let expected = "// Generated by commection. Do not edit.
// ignore_for_file: camel_case_types, constant_identifier_names, always_use_package_imports
import 'package:fast_immutable_collections/fast_immutable_collections.dart';
import 'package:meta/meta.dart';




";
        assert_eq!(actual, expected);
    }
}
